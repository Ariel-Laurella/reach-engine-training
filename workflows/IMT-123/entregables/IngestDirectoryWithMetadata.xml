<!--
This workflow is inteded to ingest files, creating new asset and fill metadata according to a given CSV.
It devives from _anyDirectoryIngest.xml workflow.
.
-->

<workflow xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://levelsbeyond.com/schema/workflow"
	xmlns:nimbus="http://levelsbeyond.com/schema/workflow/nimbus"
	xsi:schemaLocation="http://levelsbeyond.com/schema/latest http://levelsbeyond.com/schema/latest/studio.xsd"
    id="IngestDirectoryWithMetadata"
    name="Ingest Directory With Metadata"
    executionLabelExpression="Ingest Directory With Metadata | Directory: ${directoryToIngest.absolutePath}"
    deadlineExpression=""
	subjectDOClassName=""
    resultDataDef=""
    showInUserInterface="true"
    sdkVersion="5.21"
	>

	<initialStepName>check if directory is empty</initialStepName>
	
	
	<!-- ................................................... Initial Checks .................................................... -->

	<noopStep name="check if directory is empty"
		executionLabelExpression="are there files in the directory? ${filesToIngest != null AND filesToIngest.size() &gt; 0}"
		>
		<transition condition="${filesToIngest != null AND filesToIngest.size() &gt; 0}">
			<targetStepName>copy csv from S3 to Local</targetStepName>
		</transition>
		<transition condition="true">
			<targetStepName>no files to process</targetStepName>
		</transition>
	</noopStep>


	<copyFileStep name="copy csv from S3 to Local"
				  executionLabelExpression="copy csv file from S3 to Local Reachengine"
				  sourceFileExpression="${csvMetadataFile}"
				  targetDirectoryExpression="${localDirectoryPath}/${uuid}"
				  targetFilenameExpression="${uuid}.csv"
				  createTargetDirectoryFlag="true"
				  nextStep="copy json from S3 to temp directory" />


	<copyFileStep name="copy json from S3 to temp directory"
				  executionLabelExpression="copy json from S3 to Local Reachengine"
				  sourceFileExpression="${jsonMappingFile}"
				  targetDirectoryExpression="${localDirectoryPath}/${uuid}"
				  targetFilenameExpression="${uuid}.json"
				  nextStep="get metadata list from csv" />

<!--Convert csv to Json format  -->
	<groovyStep	name="get metadata list from csv"
				   resultDataDef="MetadataFull"
				   executionLabelExpression="getting metadata from csv"
				   continueOnException="true"
				   nextStep="delete temp csv and json files"
	>
		<script>
			<![CDATA[

			import groovy.json.JsonOutput
			import groovy.json.JsonSlurper

def jsonMappingPath = localDirectoryPath + "/"+ uuid + "/"+ uuid + ".json"
def csvMetadataPath = localDirectoryPath +"/" + uuid + "/"+ uuid + ".csv"

def jsonMappingSlurper = new JsonSlurper()
def jsonRows = new ArrayList()
def reachFieldNames = new ArrayList()
def csvColumnPosition = new ArrayList()
def csvRows = new ArrayList()
def jsonMappingelemnts = [:]
def realRecordOIDname = ""

File jsonFileToProcess = new File(jsonMappingPath)
File csvFileToProcess = new File(csvMetadataPath)

//Parse scv file
csvFileToProcess.eachLine {
    csvRows.add(it)
}


//save reachFieldNames from the Json mapping
def csvHeader = csvRows[0].split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*\$)")
jsonMappingelemnts = jsonMappingSlurper.parse(jsonFileToProcess)

for (int i = 0; i < jsonMappingelemnts.size(); i++) {
   if (jsonMappingelemnts.keySet()[i] == "uuid")
   {
       realRecordOIDname = jsonMappingelemnts.values()[i]
   }

    for (int j = 0; j < csvHeader.size(); j++)
    {
        if (jsonMappingelemnts.keySet()[i] == csvHeader[j])
        {

            reachFieldNames.add(jsonMappingelemnts.values()[i])
            csvColumnPosition.add(j)
        }
        if (csvHeader[j] == "fileName" && i == 0)
        {
            reachFieldNames.add("fileName")
            csvColumnPosition.add(j)
        }
    }

}
//remove HeaderRow from array csvRows
csvRows.remove(0)


// start loop over the lines in the CSV
def rowCounter = 0

for (def row in csvRows){
    rowCounter++
    Map mapSingleLine = [:]

    if (row == null || !row.contains(",") ){
        continue
    }

    //def splitRow = row.split(",")
    def splitRow = row.split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*\$)")


    for (int j = 0; j < csvColumnPosition.size(); j++)
    {
        def rowValue
        try {

            rowValue = (j < splitRow.size()) ? splitRow[csvColumnPosition[j]]: ""

        }
        catch (Exception e)
        {
            rowValue = ""
        }

 		if (rowValue != "" &&  reachFieldNames[j] == "keywords")
        {
        	rowValue = rowValue.replace(",","|").replace("\"","")
        }

        mapSingleLine.put(reachFieldNames[j], rowValue)
    }
    mapSingleLine.put("proxyTriage","false")
    mapSingleLine.put("state","pending")
    mapSingleLine.put("message","")


    jsonRows.add(mapSingleLine)

}

//debug bad rows: those rows with same recordOID or empty recordOID
// or same filename in the same sheet before processing.
for(int i=0; i<jsonRows.size() ; i++)
{
    Map mapSingleLine = jsonRows[i]

    if (mapSingleLine.get("state") == "failed")
    {
        continue
    }

    if (mapSingleLine.get(realRecordOIDname) == "")
    {
        mapSingleLine.replace("state","failed")
        mapSingleLine.replace("message","Row "+ (i+2).toString() +" in the sheet: "+ realRecordOIDname +" is empty for file " + mapSingleLine.get("fileName"))
        jsonRows.set(i, mapSingleLine)
    }
    else
    {
        for(int j=i; j<jsonRows.size() ; j++)
        {
            Map mapLineIterator = jsonRows[j]
            if (i != j && mapSingleLine.get(realRecordOIDname) == mapLineIterator.get(realRecordOIDname))
            {
                mapLineIterator.replace("state", "failed")
                mapLineIterator.replace("message", "Row "+ (j+2).toString() +" in the sheet: File " + mapSingleLine.get("fileName") + " in the present sheet has the same "+realRecordOIDname+ ": " + mapSingleLine.get(realRecordOIDname))
                jsonRows.set(j,mapLineIterator)
            }
        }
    }

}

return jsonRows


       ]]>
		</script>
	</groovyStep>

	<deleteFileStep name="delete temp csv and json files"
					executionLabelExpression="deleting temp path: ${localDirectoryPath}/${uuid}"
					sourceFilesExpression="${localDirectoryPath}/${uuid}"
					continueOnException="true"
					nextStep="query for running subflows"
	/>



	<!-- ................................................... Queue Loop 1 ................................................... -->
	<queryStep name="query for running subflows"
			   targetDataObjectClass="WorkflowExecution"
			   resultDataDef="executingSubflows"
			   executionLabelExpression="checking for workflows (with name = ${subflowName}) that match this directory that are also not in a finished state"
			   devStep="false"
			   nextStep="get number of files to ingest"
	>
		<criteria>
			<![CDATA[
            <criteria>
                <and>
                    <condition property="workflowVersion.workflow.key" op="eq">
                        <test value="${ingestSubflow}"/>
                    </condition>
                    <condition property="executionLabel" op="like">
							<test value="%${T(org.apache.commons.lang.StringEscapeUtils).escapeXml(directoryToIngest.absolutePath)}%" />
						</condition>
                    <condition property="status" op="in">
                        <tests>
                            <test value="CREATED" />
                            <test value="QUEUED" />
                            <test value="EXECUTING" />
                         </tests>
                    </condition>
                </and>
            </criteria>
            ]]>
		</criteria>
	</queryStep>


	<!-- get number of files to ingest. We work with the following variables:
	  "totalFiles" 				(T) : Total files in directory.
	  "filesToIngestNow" 		(F) : files allowed to ingest. Between 4 and 11 depending on another instances running.
	  "fileIndex" 				(I) : current index position to ingest according to list "filesToIngest".
      "initialFileIndex			(Ii): initial index position from each new calculous of (F).
	  "executingSubflows.size()"(P) : current instances of ingest running.

	  the following logic try to not overwhelm system with more than 11 files simultaneously processing:

	  If P>10 then wait 10 seconds and ask again
	  elseif (T-I>11 or 11-P<T-I)  then F = 11 - P
	  else F = T - I
	  -->

	<noopStep name="get number of files to ingest">
		<transition condition="${executingSubflows.size() == 0 AND fileIndex == totalFiles }">
			<targetStepName>set notification with failed items</targetStepName>
		</transition>
		<transition condition="${executingSubflows.size() &gt; 10  OR (executingSubflows.size() != 0 AND fileIndex == totalFiles)}">
			<targetStepName>wait some time</targetStepName>
		</transition>
		<transition condition="${ (totalFiles - fileIndex) &gt; 11 OR (11 - executingSubflows.size()) &lt; (totalFiles - fileIndex)}">
			<targetStepName>set amount of files to ingest level 1</targetStepName>
		</transition>
		<transition condition="${true}">
			<targetStepName>set amount of files to ingest level 2</targetStepName>
		</transition>
	</noopStep>

	<setContextData name="set amount of files to ingest level 1"
					nextStep="set file name to ingest"
	>
		<set targetDataDef="filesToIngestNow" 	valueExpression="${11 - executingSubflows.size()}" />
		<set targetDataDef="initialFileIndex"   valueExpression="${fileIndex}"/>
	</setContextData>

	<setContextData name="set amount of files to ingest level 2"
					nextStep="set file name to ingest"
	>
		<set targetDataDef="filesToIngestNow" 	valueExpression="${totalFiles - fileIndex}" />
		<set targetDataDef="initialFileIndex"   valueExpression="${fileIndex}"/>
	</setContextData>


<!-- ................................................... Queue Loop 2:  ............................................ -->
<!-- second loop from here to send "filesToIngestNow" in parallel ...........-->


	<!-- Search file in the sheet and return metadata that match -->
	<setContextData name="set file name to ingest"
					targetDataDef="baseFilename"
					valueExpression="${#filename(filesToIngest[fileIndex])}"
					nextStep="search metadata for file"/>


	<groovyStep	name="search metadata for file"
				   resultDataDef="jsonMetadata"
				   executionLabelExpression="searching metadata for file ${filesToIngest[fileIndex] "
	>
		<transition condition="${jsonMetadata != null AND jsonMetadata.size() &gt; 0}">
			<targetStepName>query for recordOID</targetStepName>
		</transition>
		<transition condition="${true}">
			<targetStepName>end</targetStepName>
		</transition>
		<script>
			<![CDATA[

		// get metadata related to the file to ingest

		import groovy.json.JsonOutput
		import groovy.json.JsonSlurper

		mapMetadata = [:]
		def slurper = new JsonSlurper()
		Map[] jsonList = slurper.parseText(MetadataFull.toString())

		for (def jsonRow in jsonList)
		{
			if(jsonRow.get("fileName") == baseFilename && jsonRow.get("state") == "pending" )
			{
				mapMetadata = jsonRow
				break
			}
		}

		return mapMetadata
       ]]>
		</script>
	</groovyStep>


	<!-- Verify if recordOID already exists in RE -->
	<queryStep name="query for recordOID"
			   executionLabelExpression="Verifying if recordOID already exist"
			   targetDataObjectClass="AssetMaster"
			   resultDataDef="resultObject"

	>
		<transition condition="${resultObject != null}">
			<targetStepName>update metadata list with recordOID duplicated</targetStepName>
		</transition>
		<transition condition="${true}">
			<targetStepName>update metadata list with running ingest</targetStepName>
		</transition>

		<criteria>
			<![CDATA[
                <criteria>
                    <and>
                        <condition property="metadata.recordOID" op="eq">
                            <test value="${ jsonMetadata.get('recordOID').asText()}"/>
                        </condition>
                    </and>
                </criteria>
            ]]>
		</criteria>
	</queryStep>


	<!-- update metadata list: fail ingest because recordOID is duplicated-->
	<groovyStep	name="update metadata list with recordOID duplicated"
				   resultDataDef="MetadataFull"
				   executionLabelExpression="searching metadata for file ${filesToIngest[fileIndex] "
				   nextStep="increment file index"
	>
		<script>
			<![CDATA[
		// update metadata list: fail ingest because another content has the same recordOID

		import groovy.json.JsonOutput
		import groovy.json.JsonSlurper

		def slurper = new JsonSlurper()
		Map[] jsonList = slurper.parseText(MetadataFull.toString())
		Map mapMetadata = slurper.parseText(jsonMetadata.toString())

		for (int i = 0;i < jsonList.size(); i++)
		{
			if(jsonList[i].get("fileName") == mapMetadata.get("fileName") && jsonList[i].get("state") == "pending" )
			{
				jsonList[i].replace("state", "failed")
				jsonList[i].replace("message", "Row "+ (i+2).toString() +" in the sheet: File " + mapMetadata.get("fileName") + " not ingested. The recordOID is duplicated: "+ mapMetadata.get("recordOID"))
				break
			}
		}

		return jsonList

       ]]>
		</script>
	</groovyStep>


	<!-- update metadata list: running ingest-->
	<groovyStep	name="update metadata list with running ingest"
				   resultDataDef="MetadataFull"
				   executionLabelExpression="searching metadata for file ${filesToIngest[fileIndex] "
				   nextStep="update category metadata to ingest"
	>
		<script>
			<![CDATA[
		// update metadata list: fail ingest because another content has the same recordOID

		import groovy.json.JsonOutput
		import groovy.json.JsonSlurper

		def slurper = new JsonSlurper()
		Map[] jsonList = slurper.parseText(MetadataFull.toString())
		Map mapMetadata = slurper.parseText(jsonMetadata.toString())

		for (int i = 0;i < jsonList.size(); i++)
		{
			if(jsonList[i].get("fileName") == mapMetadata.get("fileName") && jsonList[i].get("state") == "pending" )
			{
				jsonList[i].replace("state", "running")
				break
			}
		}

		return jsonList

       ]]>
		</script>
	</groovyStep>

	<!-- update categories metadata to ingest-->
	<groovyStep	name="update category metadata to ingest"
				   resultDataDef="categoryNames"
				   executionLabelExpression="updating metadata about category"
				   nextStep="process file"
	>
		<script>
			<![CDATA[
		// update categories metadata to ingest

		import groovy.json.JsonOutput
		import groovy.json.JsonSlurper

		def categories = new ArrayList()
		def slurper = new JsonSlurper()
		Map mapMetadata = slurper.parseText(jsonMetadata.toString())

		def catElements =  mapMetadata.get("category").replace("\"","").split(",")

		for (def catElement in catElements){
			categories.add(catElement)
		}


		return categories
       ]]>
		</script>
	</groovyStep>


	<executeSubflowStep name="process file"
						executionLabelExpression="Ingesting file ${filesToIngest[fileIndex]}"
						targetWorkflowId="${ingestSubflow}"
						subjectChangePath="${filesToIngest[fileIndex]}"
						subflowTargetDataDef="fileToIngest"
						resultDataDef="jsonResultList"
						waitForCompletionExpression="false"
						continueOnException="true"
						nextStep="increment file index"

	>
		<!-- ingest -->
		<subflowContextDataMapping parentDataDef="sourceAsMezz"             subflowDataDef="sourceAsMezz"/>
		<subflowContextDataMapping parentDataDef="checkForDuplicate"        subflowDataDef="checkForDuplicate"/>
		<subflowContextDataMapping parentDataDef="overwriteExisting"        subflowDataDef="overwriteExisting"/>
		<subflowContextDataMapping parentDataDef="versionDuplicate"         subflowDataDef="versionDuplicate"/>
		<!-- metadata -->
		<subflowContextDataMapping parentDataDef="failOnMetadataError"      subflowDataDef="failOnMetadataError"/>
		<subflowContextDataMapping parentDataDef="collections"              subflowDataDef="collections"/>
		<subflowContextDataMapping parentDataDef="metadataForm"             subflowDataDef="metadataForm"/>
		<subflowContextDataMapping parentDataDef="metadataFormType"         subflowDataDef="metadataFormType"/>
		<subflowContextDataMapping parentDataDef="categories"               subflowDataDef="categories"/>
		<subflowContextDataMapping parentDataDef="categoryNames"            subflowDataDef="categoryNames"/>
		<subflowContextDataMapping parentDataDef="jsonMetadata"             subflowDataDef="jsonMetadata"/>
		<subflowContextDataMapping parentDataDef="linkMetadata"             subflowDataDef="linkMetadata"/>
		<subflowContextDataMapping parentDataDef="categoryNoDepartment"     subflowDataDef="categoryNoDepartment"/>
		<subflowContextDataMapping parentDataDef="collectionDefault"     	subflowDataDef="collectionDefault"/>

		<!-- proxies -->
		<subflowContextDataMapping parentDataDef="failOnProxiesError"       subflowDataDef="failOnProxiesError"/>
		<subflowContextDataMapping parentDataDef="prioritiesJson"           subflowDataDef="prioritiesJson"/>
		<subflowContextDataMapping parentDataDef="createMezz"               subflowDataDef="createMezz"/>
		<subflowContextDataMapping parentDataDef="createProxy"              subflowDataDef="createProxy"/>
		<subflowContextDataMapping parentDataDef="createThumbVideo"         subflowDataDef="createThumbVideo"/>
		<subflowContextDataMapping parentDataDef="createThumb"              subflowDataDef="createThumb"/>
		<subflowContextDataMapping parentDataDef="videoMezzTemplate"        subflowDataDef="videoMezzTemplate"/>
		<subflowContextDataMapping parentDataDef="videoProxyTemplate"       subflowDataDef="videoProxyTemplate"/>
		<subflowContextDataMapping parentDataDef="videoThumbVideoTemplate"  subflowDataDef="videoThumbVideoTemplate"/>
		<subflowContextDataMapping parentDataDef="videoThumbnailPercentage" subflowDataDef="videoThumbnailPercentage"/>
		<subflowContextDataMapping parentDataDef="audioProxyTemplate"       subflowDataDef="audioProxyTemplate"/>
		<subflowContextDataMapping parentDataDef="imageProxyArguments"      subflowDataDef="imageProxyArguments"/>
		<subflowContextDataMapping parentDataDef="imageThumbArguments"      subflowDataDef="imageThumbArguments"/>
		<subflowContextDataMapping parentDataDef="documentProxyArguments"   subflowDataDef="documentProxyArguments"/>
		<subflowContextDataMapping parentDataDef="documentThumbArguments"   subflowDataDef="documentThumbArguments"/>
	</executeSubflowStep>

	<setContextData name="increment file index"
					targetDataDef="fileIndex"
					valueExpression="${fileIndex + 1}"
	>
		<transition condition="${fileIndex == filesToIngestNow + initialFileIndex}">
			<targetStepName>query for running subflows</targetStepName>
		</transition>
		<transition condition="${true}">
			<targetStepName>set file name to ingest</targetStepName>
		</transition>
	</setContextData>


	<delayStep 	name="wait some time"
			   	delaySecondsExpression="10"
				nextStep="query for running subflows"
	/>
<!-- ................................................... Finish Loop ............................................... -->


<!-- .......................................Notifications ......................................................... -->
<!-- The steps below are intended to make a final message with all errors to send by email to the user. I know that is
     not the best way to make it. It is a work arround, because it was too late when I could understand the difference
     between asynchronious and parallel excecution of the subflow "process file" above.

     Unfortunatelly, I am not able at this time to test the notifications. something happened with the test envirenment
     of RE. Sudenly it stop working some module on RE, because no groovy step start. In fact at this time, 06/02/2020
     3:12 pacific I tried to submit a standard workflow like "Any asset ingest" and it dont work.

-->

	<!--make notificationResult with failed rows in the sheet -->
	<groovyStep	name="set notification with failed items"
				   resultDataDef="notificationResult"
				   executionLabelExpression="setting notification with failed items"
				   nextStep="set json element to process pending records"
	>
		<script>
			<![CDATA[

		import groovy.json.JsonOutput
		import groovy.json.JsonSlurper

		def slurper = new JsonSlurper()
		Map[] jsonList = slurper.parseText(MetadataFull.toString())
		def resultString = ""

		for (def jsonRow in jsonList)
		{
			if(jsonRow.get("state") == "failed" )
			{
				resultString = resultString + "\r\n" + jsonRow.get("message")
			}
		}

		return resultString
       ]]>
		</script>
	</groovyStep>



	<!--get json element for pending elemnts of the sheet that need to be verified-->
	<groovyStep	name="set json element to process pending records"
				   resultDataDef="jsonMetadata"
				   executionLabelExpression="setting json element ${jsonIndex} to process"
	>
		<transition condition="${jsonMetadata != null AND jsonMetadata.size() &gt; 0}">
			<targetStepName>ask for null jsonMetadata</targetStepName>
		</transition>
		<transition condition="${true}">
			<targetStepName>increment index</targetStepName>
		</transition>
		<script>
			<![CDATA[

			mapMetadata = [:]
			def slurper = new JsonSlurper()
			Map[] jsonList = slurper.parseText(MetadataFull.toString())

			for (int i = jsonIndex; i<jsonList.size(); i++)
			{
				if(jsonList[i].get("state") == "pending" )
				{
					mapMetadata.put("recordOID",jsonList[i].get("recordOID"))
					mapMetadata.put("fileName",jsonList[i].get("fileName"))
					mapMetadata.put("collection",jsonList[i].get("collection"))
					mapMetadata.put("category",jsonList[i].get("category"))
					mapMetadata.put("index",i)
					break
				}
			}

			return mapMetadata
       ]]>
		</script>
	</groovyStep>

	<noopStep name="ask for null jsonMetadata">
		<transition condition="${jsonMetadata != null AND jsonMetadata.size() &gt; 0}">
			<targetStepName>set new JsonIndex</targetStepName>
		</transition>
		<transition condition="${true}">
			<targetStepName>verify if fail or success message</targetStepName>
		</transition>
	</noopStep>


	<!--set new JsonIndex -->
	<setContextData name="set new JsonIndex"
					targetDataDef="jsonIndex"
					valueExpression="${jsonMetadata.get('index').asInt()}"
					nextStep="query for recordOID"
	/>


	<!--Get category value from recordOID-->
	<queryStep name="query for recordOID"
			   executionLabelExpression="Verifying if recordOID already exist"
			   targetDataObjectClass="AssetMaster"
			   resultDataDef="resultObject"

	>
		<transition condition="${resultObject != null}">
			<targetStepName>query for collection</targetStepName>
		</transition>
		<transition condition="${true}">
			<targetStepName>fail for recordOID not found</targetStepName>
		</transition>

		<criteria>
			<![CDATA[
                <criteria>
                    <and>
                        <condition property="metadata.recordOID" op="eq">
                            <test value="${ jsonMetadata.get('recordOID').asText()}"/>
                        </condition>
                    </and>
                </criteria>
            ]]>
		</criteria>
	</queryStep>

	<!-- fail for recordOID not found -->
	<groovyStep	name="fail for recordOID not found"
				   resultDataDef="notificationResult"
				   executionLabelExpression="setting recordOID not found"
				   nextStep="increment index"
	>
		<script>
			<![CDATA[
			def resultString = notificationResult + "\r\n" + jsonMetadata.get("fileName") + " not ingested or recordIOD not found."
			return resultString
       ]]>
		</script>
	</groovyStep>

	<!--check if asset is in collection orphaned -->
	<queryStep name="query for collection"
			   targetDataObjectClass="AssetCollection"
			   executionLabelExpression="check if asset is in collection orphaned"
			   resultDataDef="collection"
	>
		<transition condition="${collection == null}">
			<targetStepName>query for category</targetStepName>
		</transition>
		<transition condition="${true}">
			<targetStepName>fail for collection orphaned</targetStepName>
		</transition>

		<criteria>
			<![CDATA[
                <criteria>
                    <and>
                        <condition property="name" op="eq">
                            <test value="orphaned" />
                        </condition>
                    </and>
                </criteria>
            ]]>
		</criteria>
	</queryStep>

	<!-- fail for collection orphaned -->
	<groovyStep	name="fail for collection orphaned"
				   resultDataDef="notificationResult"
				   executionLabelExpression="setting recordOID not found"
				   nextStep="query for category"
	>
		<script>
			<![CDATA[
			def resultString = notificationResult + "\r\n" + jsonMetadata.get("fileName") + " has failed to add in collection " + jsonMetadata.get("collection") + ". It is in orphaned collection."
			return resultString
       ]]>
		</script>
	</groovyStep>



	<!--check if category asigned to asset in the sheet exist.
	    If no, then the asset would be added to -no department -->
	<queryStep name="query for category"
			   executionLabelExpression="Querying for the category Found"
			   targetDataObjectClass="AssetCategory"
			   resultDataDef="combinedCategories"
	>
		<transition condition="${(jsonMetadata.get('category').asText() != '' AND combinedCategories.size() == 0)}">
			<targetStepName>fail for category not found</targetStepName>
		</transition>
		<transition condition="${true}">
			<targetStepName>increment index</targetStepName>
		</transition>

		<criteria>
			<![CDATA[
				<criteria>
					<and>
						<condition property="name" op="eq">
							<test value="${jsonMetadata.get('category').asText()}" />
						</condition>
					</and>
				</criteria>
			]]>
		</criteria>
	</queryStep>


	<!-- fail for category not foud -->
	<groovyStep	name="fail for category not found"
				   resultDataDef="notificationResult"
				   executionLabelExpression="setting category not found"
				   nextStep="increment index"
	>
		<script>
			<![CDATA[
			def resultString = notificationResult + "\r\n" + jsonMetadata.get("fileName") + " has assigned the category " + jsonMetadata.get("category") + ", but it does not exist on Reachengine. Verify if the asset was added to the no department category."
			return resultString
       ]]>
		</script>
	</groovyStep>


	<!-- set to next element -->
	<setContextData name="increment index"
					targetDataDef="jsonIndex"
					valueExpression="${jsonIndex + 1}"
	>
		<transition condition="${jsonIndex == MetadataFull.size()}">
			<targetStepName>verify if fail or success message</targetStepName>
		</transition>
		<transition condition="${true}">
			<targetStepName>set json element to process pending records</targetStepName>
		</transition>
	</setContextData>


	<!-- verify if there are no errors, then make a success message -->

	<groovyStep	name="verify if fail or success message"
				   resultDataDef="notificationResult"
				   executionLabelExpression="verifying if fail or success message"
				   nextStep="sendEmail"
	>
		<script>
			<![CDATA[
			def resultString = notificationResult

			if (resultString == "")
			{
				resultString = "Dear user, no error has been found during the ingest process."
			}
			else
			{
				resultString =  "Dear user, find below the erros during the ingest process. " + "\r\n" + notificationResult
			}
			return resultString
       ]]>
		</script>
	</groovyStep>








	<emailStep 	name="sendEmail"  emailAddressesExpression="${userEmailAddress}"
				  subjectExpression="Ingest of Directory Completed: ${directoryToIngest.absolutePath}"
				  nextStep="end"
	>
		<body>
			<![CDATA[    ${notificationResult}  ]]>
		</body>
	</emailStep>



	<!-- ................................................... End Steps .................................................... -->
	<!-- success -->


	<noopStep name="no files to process"
		executionLabelExpression="No files in ${directoryToIngest.absolutePath}."
		pctComplete="99"
		nextStep="end"
		/>
	
	
	<noopStep name="end"    pctComplete="100"/>


	<!-- fail -->
	<failWorkflowStep name="workflow is running"
		executionLabelExpression="Workflow already executing on the directory"
		reasonExpression="Workflow already executing on the directory"
		/>
	
	
	<!-- ............................................... Context Data Defs ................................................ -->

	<!-- ....... User Input Variables ........ -->
	<contextDataDef name="directoryToIngest" 		dataType="Directory"	userInput="true"    label="Directory To Ingest"  required="true" displayIndex="1" />
	<contextDataDef name="csvMetadataFile" 			dataType="File"			userInput="true"    label="Metadata File (.csv)"  required="true" displayIndex="2" />
	<contextDataDef name="jsonMappingFile" 			dataType="File"			userInput="true"    label="Mapping File (.json)"  required="true" displayIndex="3" />

	<contextDataDef name="jsonMetadata" 			dataType="JSON" />
	<contextDataDef name="MetadataFull" 			dataType="JSON" multiple="true"   />
	<contextDataDef name="jsonResultList" 			dataType="JSON" multiple="true"   />
	<contextDataDef name="notificationResult" 		dataType="String" />
	<contextDataDef name="userEmailAddress" 		dataType="String" 		defaultDataExpression="${#this.startedBy.emailAddress}"/>

	<contextDataDef name="uuid"  		 			dataType="String"  defaultDataExpression="${#uuid().toString()}" />
	<contextDataDef name="localDirectoryPath"   	dataType="String"  defaultDataExpression="/reachengine/media/temp" />
	<contextDataDef name="categoryNoDepartment" 	dataType="String"	multiple="true" defaultDataExpression="no department" />
	<contextDataDef name="collectionDefault" 		dataType="String"	defaultDataExpression="orphaned" />
	<contextDataDef name="baseFilename" 			dataType="String" />


	<contextDataDef name="resultObject" dataType="Data Object" />
	<contextDataDef name="jsonIndex" 				dataType="Integer" defaultDataExpression="0" />


	<!-- .......... Input Variables .......... -->
	<!-- ingest options (defaults in subflow) -->
	<contextDataDef name="sourceAsMezz"             dataType="Boolean"/>
	<contextDataDef name="checkForDuplicate"        dataType="Boolean"/>
	<contextDataDef name="overwriteExisting"        dataType="Boolean"/>
	<contextDataDef name="versionDuplicate"         dataType="Boolean"/>
	<!-- transcode options -->
	<contextDataDef name="failOnProxiesError"       dataType="Boolean"/>
	<contextDataDef name="asyncProxies"             dataType="Boolean"/>
	<!-- create proxies? (defaults in subflows) -->
	<contextDataDef name="prioritiesJson"           dataType="JSON">
		<description>
			A JSON with the structure:
				{"mezzanine":w, "proxy":x, "thumbnailVideo":y, "thumbnail":z}
		</description>
	</contextDataDef>
	<contextDataDef name="createMezz"               dataType="Boolean"/>
	<contextDataDef name="createProxy"              dataType="Boolean"/>
	<contextDataDef name="createThumb"              dataType="Boolean"/>
	<contextDataDef name="createThumbVideo"         dataType="Boolean"/>
	<!-- supply a file for proxies? -->
	<contextDataDef name="mezzFile"                 dataType="File"/>
	<contextDataDef name="proxyFile"                dataType="File"/>
	<contextDataDef name="thumbFile"                dataType="File"/>
	<contextDataDef name="thumbVideoFile"           dataType="File"/>
	<!-- Templates/Args for proxies creation (defaults in subflows) -->
	<contextDataDef name="videoMezzTemplate"    	dataType="String"/>
	<contextDataDef name="videoProxyTemplate"    	dataType="String"/>
	<contextDataDef name="videoThumbVideoTemplate"  dataType="String"/>
	<contextDataDef name="videoThumbnailPercentage" dataType="Integer"/>
	<contextDataDef name="audioProxyTemplate"       dataType="String"/>
	<contextDataDef name="imageProxyArguments"      dataType="String"/>
	<contextDataDef name="imageThumbArguments"      dataType="String"/>
	<contextDataDef name="documentProxyArguments"   dataType="String"/>
	<contextDataDef name="documentThumbArguments"   dataType="String"/>
	
	<!-- ....... Processing Variables ........ -->
	<contextDataDef name="currentExecutions" 	    dataType="Data Object" 	multiple="true"/>
	<contextDataDef name="filesToIngest" 		    dataType="File"		    multiple="true"     defaultDataExpression="${#walkDir(directoryToIngest, null)}"/>
	<contextDataDef name="totalFiles" 				dataType="Integer"		defaultDataExpression="${filesToIngest.size()}" />
	<contextDataDef name="filesToIngestNow"         dataType="Integer"		defaultDataExpression="0"/>
	<contextDataDef name="fileIndex"		        dataType="Integer" defaultDataExpression="0"/>
	<contextDataDef name="initialFileIndex"	        dataType="Integer" defaultDataExpression="0"/>

	<contextDataDef name="everyThingOK"				 dataType="Boolean" defaultDataExpression="true" />
	<contextDataDef name="bodyReport"				 dataType="String"  defaultDataExpression="" />

	<!-- queue loop variables -->
	<contextDataDef name="nextFiles"    		    dataType="File" 		multiple="true"/>
	<contextDataDef name="executingSubflows" 	    dataType="Data Object" 	multiple="true"/>
	<contextDataDef name="queueLimit" 			    dataType="Integer" 		defaultDataExpression="${#sysconfig('workflows.default.ingestDirectory.queueLimit') ?: 11}"/>
	<contextDataDef name="batchSize" 		        dataType="Integer" 		defaultDataExpression="${#sysconfig('workflows.default.ingestDirectory.batchSize') ?: 10}"/>
	<contextDataDef name="queryPollInterval"  	    dataType="Integer" 		defaultDataExpression="${#sysconfig('workflows.default.ingestDirectory.queryPollInterval') ?: 60}"/>
	<contextDataDef name="ingestSubflow"      	    dataType="String" 		defaultDataExpression="IngestAssetWithMetadata"/>


	<contextDataDef name="recordNumber" 			dataType="String" defaultDataExpression="100201"  />


	<contextDataDef name="collections"              dataType="Data Object"  multiple="true" defaultDataExpression="${subject}" />
	<contextDataDef name="metadataForm"             dataType="MetadataForm" label="Metadata Form"/>
	<contextDataDef name="collection"            	dataType="Data Object"         />
	<contextDataDef name="combinedCategories"   	dataType="Data Object"      multiple="true"/>

	<!-- metadata options -->
	<contextDataDef name="failOnMetadataError"      dataType="Boolean"/>
	<contextDataDef name="categories"               dataType="Data Object"  multiple="true"/>
	<contextDataDef name="categoryNames"            dataType="String"           multiple="true"/>
	<contextDataDef name="jsonMetadata"             dataType="JSON">
		<description>
			Single JSON where:
			Keys are metadata property names
			Values are what to set the matching property to on this asset
		</description>
	</contextDataDef>
	<contextDataDef name="linkMetadata"             dataType="JSON"             multiple="true">
		<description>
			Array of JSONs where:
			Each JSON has 2 Keys (propertyName and linkInfo):
			propertyName's value is a metadata property name of type link
			linkInfo's value is a JSON with 2 keys (title and url):
			title's value is the display name for the link
			url's value is the url to open when the title is clicked on
		</description>
	</contextDataDef>
	<contextDataDef name="metadataFormType"         dataType="String"           defaultDataExpression="access">
		<description>
			TEMPORARY!!! (Forms will be standardized to the same format in the future)
			Valid types = "access" or "panel"
		</description>
	</contextDataDef>

</workflow>
